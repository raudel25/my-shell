char *commands[17] = { "my_shell",
"cd",
"exit",
"pipes",
"background",
"fg",
"jobs",
"history",
"again",
"ctrl+c",
"chain",
"conditional",
"true",
"false",
"get",
"set",
"unset",
};
char *commands_help[17] = { "Raudel Alejandro Gómez Molina\n\nFuncionalidades:\n\nbasic: funcionalidades básicas\npipes: implementación de múltiples tuberías\nbackground: permite correr procesos en el background\nspaces: los comandos pueden estar separados por cualquier cantidad de espacios\nhistory: se almacena un historial de comandos\nctrl+c: finaliza el proceso actual\nchain: permite ejecutar múltiples comandos en una sola línea y comandos de forma condicional\nconditional: permite ejecutar comandos de forma condicional\nvariables: permite almacenar variables\n\nComandos:\n\ncd: cambia de directorio\nexit: finaliza la ejecución del shell\nfg: trae hacia el foreground el último proceso enviado al background\njobs: lista todos los procesos en el background\nhistory: muestra el historial de comandos\nagain: ejecuta un comando almacenado en el historial\ntrue: representa un comando que siempre se ejecuta con éxito\nfalse: representa un comando que nunca se ejecuta con éxito\nget: muestra el valor de las variables\nset: modifica el valor de una variable\nunset: elimina una variable\n\nTotal: 10 puntos\n",
"El comando cd <dir> cambia el directorio actual del shell al directorio especificado por el usuario, si <dir> no se  especifica se toma por default el home como directorio.\n\nEjemplo:\n\nmy_sh $ cd new_dir # se mueve hacia la carpeta new_dir\nmy_sh $ cd         # se mueve hacia home\n\nImplementación:\n\nSe utiliza la función chdir() de c.\n ",
"El comando exit finaliza la ejecución del shell.\n\nImplementación:\n\nSe ejecuta la función exit(EXIT_SUCCESS) para terminar la ejecución del shell.\n ",
"En este apartado encontramos 4 comandos ( | , < , > , >> ) que nos permitirán redirigir la entrada y la salida de los comandos que ejecutemos.\n\nEl comando command1 | command2 ejecuta <command1>, redirecciona la salida de <command1> a la entrada de <command2> y luego ejecuta <command2>.\n\nEl comando command < file redirecciona el contenido del archivo <file> a la entrada de <command> y ejecuta <command>.\n\nEl comando command > file ejecuta <command> redirecciona la salida de <command> hacia el archivo <file>, sobrescribiendo\nel contenido de <file>.\n\nEl comando command >> file hace lo mismo que el comando anterior pero escribe al final de <file> sin sobrescribir el\ncontenido de dicho archivo.\n\nAdicionalmente se pueden combinar todas estos comandos en una sola línea.\n\nEjemplo:\n\nmy_sh $ command1 | command2\nmy_sh $ command < file\nmy_sh $ command > file\nmy_sh $ command >> file\nmy_sh $ command1 < file1 | command2 | command3 > file2 # el contenido de file1 se redirecciona a la entrada de command1, la salida de command1 se redirecciona a la entrada de command2, la salida de command2 se redirecciona a la entrada de command3 y la salida de command3 se redirecciona a file2.\n\nImplementación:\n\nSe parsea el comando introducido en busca de los operadores de este apartado. En caso de que la búsqueda sea satisfactoria se identifica los argumentos a ejecutar y el file descriptor de salida y de entrada correspondientes, que se obtienen mediante la función pipe(), read() o write(). Luego se ejecuta el proceso y se atrapa la entrada y salida del proceso en el file descriptor correspondiente mediante la función dup2().\n ",
"El operador & al final de un comando ejecuta dicho comando el background esto significa que dicho comando se ejecuta  sin afectar el ciclo del shell.\n\nEjemplo:\n\nmy_sh $ cp movie.mkv .. & # el comando se envía al background\nmy_sh $ ls                # el ciclo del shell no espera a que el comando anterior termine su ejecución.\n\nImplementación:\n\nSe crea un nuevo proceso hijo con la función fork(), pero no se ejecuta el waitpid() que espera a que el proceso culmine. En cambio se almacena el pid del proceso y el nombre se este, para cuando sea necesario traer el proceso hacia el foreground.\n ",
"El comando fg <number> trae el proceso enumerado con <number> desde el background a el foreground. Si <number> no se especifica se toma el último proceso enviado hacia el background.\n\nEjemplo:\n\nmy_sh $ cp movie.mkv .. &\nmy_sh $ rm file.zip &\nmy_sh $ jobs\n[1]     cp movie.mkv ..     1925\n[2]     rm file.zip     1927\nmy_sh $ fg 1                      # el comando <cp movie.mkv ..> se trae de vuelta al foreground\n                                  # esperamos hasta que <cp movie.mkv ..> se ejecute\nmy_sh $ fg                        # el comando <rm file.zip> se trae de vuelta al foreground\n\nImplementación:\n\nEn la información que se obtuvo al enviar los comandos al background se busca el pid correspondiente, se ejecuta la función waitpid() para esperar a que termine el proceso y se elimina el proceso de los almacenados en el background.\n ",
"El comando jobs lista todos los procesos que están ocurriendo en el background.\n\nEjemplo:\n\nmy_sh $ cp movie.mkv .. &\nmy_sh $ rm file.zip &\nmy_sh $ jobs             # lista los 2 comandos anteriores ocurriendo en el background\n[1]     cp movie.mkv ..     1925\n[2]     rm file.zip     1927\n\nImplementación:\n\nSe lista la información almacenada cuando se enviaron los procesos al background.\n ",
"El comando history muestra los últimos 100 comandos ejecutados en el shell, enumerados desde 1 para el más antiguo hasta 100 para el último comando. Si el comando ejecutado empieza con espacios no será guardado en el historial.\n\nEjemplo:\n\nmy_sh $ history\n1: ls\n2: cd\n3: history\nmy_sh $ cd      # se guarda en el historial\nmy_sh $ history\n1: ls\n2: cd\n3: history\n4: cd\n5: history\nmy_sh $  hola   # no se guarda en el historial\n\nImplementación:\n\nSe usa el historial del a biblioteca readline y se guardan los comandos en el archivo .my_sh_history ubicado en /home.\n ",
"El comando again <number> ejecuta un comando almacenado en el historial <number> viene dado por el orden en que se ejecutaron los comandos desde 1 para el más viejo hasta 100 para el último, si <number> no se especifica se ejecuta el ultimo comando. Una vez que se ejecuta el comando especificado anteriormente este pasa al historial.\n\nEjemplo:\n\nmy_sh $ history\n1: ls\n2: cd\n3: pwd\n4: history\nmy_sh $ again 1 # se ejecuta ls\nmy_sh $ again   # se ejecuta ls dado que fue el último comando\n\nImplementación:\n\nSe lee el archivo .my_sh_history ubicado en /home y se busca el comando con el índice especificado.\n ",
"ctrl+c envía una señal SIGINT al comando que se está ejecutando, si se ejecuta nuevamente ctrl+c se envía una señal SIGKILL al comando que se está ejecutando.\n\nImplementación:\n\nSe utilizó la función signal de c.\n ",
"En este apartado tenemos los comandos ( ; , || , && ).\n\nEl operador ; permite ejecutar varios comandos en la misma línea.\n\nEl comando command1 && command2 ejecuta command1 y si este tiene éxito ejecuta command2\n\nEl comando command1 || command2 ejecuta command1 y si este no tiene éxito ejecuta command2 en caso contrario no se ejecuta más nada.\n\nAdicionalmente se pueden combinar todos estos comandos en una sola línea. Contamos con otros 2 comandos especiales (true, false) que simulan una condición que siempre se cumple y otra que nunca se cumple respectivamente.\n\nEjemplo:\n\nmy_sh $ command1; command2;\nmy_sh $ command1 && command2\nmy_sh $ command1 || command2\nmy_sh $ command1 && command2; || command3 # se ejecutará command1, si este tiene éxito se ejecutará command2, si ambos commandos command1 y command2 tienen éxito no se ejecutará más nada en caso contrario se ejecutará command3\n\nImplementación:\n\nSe parsea el comando introducido en busca de los operadores de este apartado. En caso de que la búsqueda sea satisfactoria se obtiene el substring correspondiente, se ejecuta está nueva instrucción y se realiza la comprobación correspondiente del éxito del proceso a ejecutar.\n ",
"En este apartado encontramos 4 comandos (if, then, else y end) que nos permiten realizar una operación condicional en una sola línea.\n\nEl comando if <condition> then <execute1> else <execute2> end, primero ejecuta el comando <condition> y si este tiene éxito entonces se ejecuta <execute1> en caso contrario se ejecuta <execute2>, end se usa para indicar en fin de la operación condicional. El comando else puede no especificarse: if <condition> then <execute> end, si <condition> tiene exito <execute> se ejecutará en caso contrario no pasa nada.\n\nAdicionalmente contamos con otros 2 comandos especiales (true, false) que simulan una condición que siempre se cumple y otra que nunca se cumple respectivamente. Adicionalmente se puede anidar una operación condicional dentro de otra.\n\nEjemplo:\n\nmy_sh $ if cond then execute end\nmy_sh $ if cond then execute1 else execute2 end\nmy_sh $ if cond1 then if cond2 then execute1 end else execute2 end\nmy_sh $ if true then execute end                                   # siempre se ejecutará execute\nmy_sh $ if false then execute end                                  # nunca se ejecutará execute\n\nImplementación:\n\nSe parsea el comando introducido en busca de los operadores de este apartado, se comprueba que los operadores a ejecutar sean parte de la misma operación, para esto llevamos un contador que aumenta al encontrar un if y disminuye al encontrar un end. En caso de que la búsqueda sea satisfactoria se obtiene el substring correspondiente, se ejecuta está nueva instrucción y se realiza la comprobación correspondiente del éxito del proceso a ejecutar.\n ",
"El comando true siempre se ejecuta con éxito, puede ver detalles de su uso en chain y conditional.\n",
"El comando false siempre falla al ejecutarse, puede ver detalles de su uso en chain y conditional.\n",
"El comando get <c> muestra el valor de la variable <c> en el sistema. Si la variable no existe el comando no tendrá éxito. Si <c> no se especifica el comando lista todas las variables.\n\nEjemplo:\n\nmy_sh $ set a hola\nmy_sh $ get a      # se muestra el valor de a\nhola\nmy_sh $ get b      # b no se encuentra el sistema\nmy_sh $ set c 25\nmy_sh $ get        # se muestran todas las variables del sistema\na = hola\nc = 25\n\nImplementación:\n\nPara almacenar las variables se utiliza un array de tamaño fijo y se indexa en el valor de dicha variable por su código ascii.\n ",
"El comando set <c> <value> permite introducir una nueva variable al sistema o modificar el valor de una ya existente. Las variables introducidas deben ser letras minúsculas del alfabeto inglés. Si <value> es está entre comillas `command` se ejecuta command y la salida de de ese comando se almacena como valor de <c>, si la salida del comando es vacía la ejecución de set no tiene éxito y por tanto no se guarda la variable.\n\nEjemplo:\n\nmy_sh $ set a hola # como a no existe se crea en el sistema con valor hola\nmy_sh $ set a `ls` # el valor de a se modifica con la salida de ls\narchivo.txt my_sh\nmy_sh $ get a\narchivo.txt my_sh\nmy_sh $ set a `cd` # la salida de cd es vacía por tanto el set falla y el valor de la variable no cambia\n\nImplementación:\n\nPara almacenar las variables se utiliza un array de tamaño fijo y se indexa en el valor de dicha variable por su código ascii. en el caso de `command` se crea un fork() se ejecuta command y se lee la salida de ese proceso.\n ",
"El comando unset <c> elimina la variable <c> del sistema con su respectivo valor. Si <c> no existe el comando no tiene éxito.\n\nEjemplo:\n\nmy_sh $ set c hola\nmy_sh $ get c\nhola\nmy_sh $ unset c # c se elimina del sistema\n\nImplementación:\n\nPara almacenar las variables se utiliza un array de tamaño fijo y se indexa en el valor de dicha variable por su código ascii.\n",
};
