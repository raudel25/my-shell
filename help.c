char *commands[16] = { "again",
"background",
"cd",
"chain",
"conditional",
"ctrl+c",
"exit",
"false",
"fg",
"get",
"history",
"jobs",
"pipes",
"set",
"true",
"unset",
};
char *commands_help[16] = { "El comando again <number> ejecuta un comando almecenado en el historial <number> viene dado por el orden en que se  ejecutaron los comandos desde 1 para el más viejo hasta 10 para el último, si <number> no se especifica se ejecuta  el ultimo comando. Una vez que se ejecuta el comando especificado anteriormente este pasa al historial.\n\nEjemplo:\n\nmy_sh $ history\n1: ls\n2: cd\n3: pwd\n4: history\nmy_sh $ again 1 # se ejecuta ls\nmy_sh $ again   # se ejecuta ls dado que fue el último comando\n",
"El operador & al final de un comando ejecuta dicho comando el background esto significa que dicho comando se ejecuta  sin afectar el ciclo del shell.\n\nEjemplo:\n\nmy_sh $ cp movie.mkv .. & # el comando se envía al background\nmy_sh $ ls                # el ciclo del shell no espera a que el comando anterior termine su ejecución.\n",
"El comando cd <dir> cambia el directorio actual del shell al directorio especificado por el usuario, si <dir> no se  especifica se toma por default el home como directorio.\n\nEjemplo:\n\nmy_sh $ cd new_dir # se mueve hacia la carpeta new_dir\nmy_sh $ cd         # se mueve hacia home\n",
"En este apartado tenemos los comandos ( ; , || , && ).\n\nEl operador ; premite ejecutar varios commandos en la misma línea.\n\nEl commando command1 && command2 ejecuta command1 y si este tiene éxito ejecuta command2\n\nEl commando command1 || command2 ejecuta command1 y si este no tiene éxito ejecuta command2 en caso contrario no se ejecuta más nada.\n\nAdicionalmente se pueden combinar todos estos comandos en una sola línea. Contamos con otros 2 comandos especiales (true, false) que simulan una condición que siempre se cumple y otra que nunca se cumple respectivamente.\n\nEjemplo:\n\nmy_sh $ command1; command2;\nmy_sh $ command1 && command2\nmy_sh $ command1 || command2\nmy_sh $ command1 && command2; || command3 # se ejecutará command1, si este tiene éxito se ejecutará command2, si ambos  commandos command1 y command2 tienen éxito no se ejecutará más nada en caso contrario se ejecutará command3\n",
"En este apartado encontramos 4  comandos (if, then, else y end) que nos permiten realizar una operación condicional en una  sola línea.\n\nEl comando if <condition> then <execute1> else <execute2> end, primero ejecuta el comando <condition> y si este tiene éxito entonces se ejecuta <execute1> en caso contrario se ejecuta <execute2>, end se usa para indicar en fin de la operación  condicional. El comando else puede no especificarse: if <condition> then <execute> end, si <condition> tiene exito <execute>  se ejecutará en caso contrario no pasa nada.\n\nAdicionalmente contamos con otros 2 comandos especiales (true, false) que simulan una condición que siempre se cumple y otra que nunca se cumple respectivamente. Adicionalmente se puede anidar una operación condicional dentro de otra.\n\nEjemplo:\n\nmy_sh $ if cond then execute end\nmy_sh $ if cond then execute1 else execute2 end\nmy_sh $ if cond1 then if cond2 then execute1 end else execute2 end\nmy_sh $ if true then execute end                                   # simpre se ejecutará execute\nmy_sh $ if false then execute end                                  # nunca se ejecutará execute\n",
"ctrl+c envía una sañal SIGINT al comando que se está ejecutando, si se ejecuta nuevamente ctrl+c se envía una sañal SIGKILL al comando que se está ejecutando.\n",
"El comando exit para la ejecución del shell.\n",
"El comando false siempre falla al ejecutarse, puede ver detalles de su uso en chain y conditional.\n",
"El comando fg <number> trae el proceso enumerado con <number> desde el background a el foreground. Si <number> no se especifica se toma el último proceso enviado hacia el background.\n\nEjemplo:\n\nmy_sh $ cp movie.mkv .. &\nmy_sh $ rm file.zip &\nmy_sh $ jobs\n[1]     cp movie.mkv ..     1925\n[2]     rm file.zip     1927\nmy_sh $ fg 1                      # el comando <cp movie.mkv ..> se trae de vuelta al foreground\n                                  # esperamos hasta que <cp movie.mkv ..> se ejecute\nmy_sh $ fg                        # el comando <rm file.zip> se trae de vuelta al foreground\n",
"El comando get <c> muestra el valor de la variable <c> en el sistema. Si la variable no existe el comando no tendrá éxito. Si <c> no se especifica el comando lista todas las variables.\n\nEjemplo:\n\nmy_sh $ set a hola\nmy_sh $ get a      # se muestra el valor de a\nhola\nmy_sh $ get b      # b no se encuentra el sistema\nmy_sh $ set c 25\nmy_sh $ get        # se muestran todas las variables del sistema\na = hola\nc = 25\n",
"El comando history muestra los últimos 10 comandos ejecutados en el shell, enumerados desde 1 para el más antiguo hasta 10  para el último comando. Si el comando ejecutado empieza con espacios no será guardado en el historial.\n\nEjemplo:\n\nmy_sh $ history\n1: ls\n2: cd\n3: history\nmy_sh $ cd      # se guarda en el historial\nmy_sh $ history\n1: ls\n2: cd\n3: history\n4: cd\n5: history\nmy_sh $  hola   # no se guarda en el historial\n",
"El comnado jobs lista todos los procesos que están ocurriendo en el background.\n\nEjemplo:\n\nmy_sh $ cp movie.mkv .. &\nmy_sh $ rm file.zip &\nmy_sh $ jobs             # lista los 2 comandos anteriores ocurriendo en el background\n[1]     cp movie.mkv ..     1925\n[2]     rm file.zip     1927\n",
"En este apartado encontramos 4 comandos ( | , < , > , >> ) que nos permitiran redirigir la entrada y la salida de los  comnados que ejecutemos.\n\nEl comando command1 | command2 ejecuta <command1>, redirecciona la salida de <command1> a la entrada de <command2> y luego ejecuta <command2>.\n\nEl comando command < file redirecciona el contenido del archivo <file> a la entrada de <command> y ejecuta <command>.\n\nEl comando command > file ejecuta <command> redirecciona la salida de <command> hacia el archivo <file>, sobrescribiendo\nel contenido de <file>.\n\nEl comando command >> file hace lo mismo que el comando anterior pero escribe al final de <file> sin sobreescribir el\ncontenido de dicho archivo.\n\nAdicionalmente se pueden combinar todas estos comandos en una sola línea.\n\nEjemplo:\n\nmy_sh $ command1 | command2\nmy_sh $ command < file\nmy_sh $ command > file\nmy_sh $ command >> file\nmy_sh $ command1 < file1 | command2 | command3 > file2 # el contenido de file1 se redirecciona a la entrada de command1, la salida de command1 se redirecciona a la entrada de command2, la salida de command2 se redirecciona a la entrada de command3 y la salida de command3 se redirecciona a file2.\n",
"El comando set <c> <value> perimite introducir una nueva variable al sistema o modificar el valor de una ya existente. Las variables introducidas deben ser letras minúsculas del alfabeto inglés. Si <value> es está entre comillas `command` se ejecuta command y la salida de de ese comando se almacena como valor de <c>, si la salida del comando es vacía la ejecución de set no tiene éxitoy por tando no se guarda la variable.\n\nEjemplo:\n\nmy_sh $ set a hola # como a no existe se crea en el sistema con valor hola\nmy_sh $ set a `ls` # el valor de a se modifica con la salida de ls\narchivo.txt my_sh\nmy_sh $ get a\narchivo.txt my_sh\nmy_sh $ set a `cd` # la salida de cd es vacía por tanto el set falla y el valor de la variable no cambia\n",
"El comando true siempre se ejecuta con éxito, puede ver detalles de su uso en chain y conditional.\n",
"El comando unset <c> elimina la variable <c> del sistema con su respectivo valor. Si <c> no existe el comando no tiene éxito.\n\nEjemplo:\n\nmy_sh $ set c hola\nmy_sh $ get c\nhola\nmy_sh $ unset c # c se elimina del sistema",
};
